// Generated by CoffeeScript 1.10.0
(function() {
  define(["js/chartingLibraries/d3_3.5.17/d3_3.5.17.min", "js/chartingLibraries/custom/sankey"], function(d3, sankey) {
    var customCharts;
    return customCharts = {
      tableSparklines: function(width, data, columns, tableId) {
        var col, l, len1, m, ref1, results, row, table, tbody, td, th, thead, tr;
        table = document.getElementById(tableId);
        table.style.width = +width + 'px';
        thead = document.createElement('thead');
        tr = document.createElement('tr');
        for (l = 0, len1 = columns.length; l < len1; l++) {
          col = columns[l];
          th = document.createElement('th');
          th.id = 'col-' + col + "-head";
          if (col.indexOf('sparkline') > -1) {
            th.className = 'td-sparkline';
          }
          th.innerHTML = col;
          tr.append(th);
        }
        thead.append(tr);
        table.append(thead);
        tbody = document.createElement('tbody');
        table.append(tbody);
        results = [];
        for (row = m = 0, ref1 = data[columns[0]].length; 0 <= ref1 ? m < ref1 : m > ref1; row = 0 <= ref1 ? ++m : --m) {
          tr = document.createElement('tr');
          tbody.append(tr);
          results.push((function() {
            var len2, n, results1;
            results1 = [];
            for (n = 0, len2 = columns.length; n < len2; n++) {
              col = columns[n];
              td = document.createElement('td');
              td.id = 'col-' + col + "-" + row;
              if (col.indexOf('sparkline') > -1) {
                td.className = 'td-sparkline';
                tr.append(td);
                results1.push(this.sparkline(data[col][row].formatted_data, "#col-" + col + "-" + row));
              } else {
                td.innerHTML = data[col][row].formatted_data;
                results1.push(tr.append(td));
              }
            }
            return results1;
          }).call(this));
        }
        return results;
      },
      sparkline: function(data, element) {
        var draw, el, height, line, width, x, y;
        el = d3.select(element);
        width = el[0][0].offsetWidth;
        height = el[0][0].offsetHeight;
        x = d3.scale.linear().range([0, width]);
        y = d3.scale.linear().range([height, 0]);
        line = d3.svg.line().x(function(d) {
          return x(d.x);
        }).y(function(d) {
          return y(d.y);
        });
        draw = function(data, element) {
          var point, svg;
          x.domain(d3.extent(data, function(d) {
            return d.x = +d.x;
          }));
          y.domain(d3.extent(data, function(d) {
            return d.y = +d.y;
          }));
          svg = d3.select(element).append('svg').attr('width', width).attr('height', height).append('path').datum(data).attr('class', 'sparkline').attr('d', line);
          point = svg.append('g').attr('class', 'sparkline-point');
          point.selectAll('circle').data(function(d) {
            return d;
          }).enter().append('circle').attr('cx', function(d) {
            return x(d.x);
          }).attr('cy', function(d) {
            return y(d.y);
          }).attr('r', 3.5).style('fill', 'white').style('stroke', 'black');
        };
        return draw(data, element);
      },
      topProduct: function(name, image, link, data) {
        var a, c, cImg, cInfo, cProduct, headding, img, infoFormatter, kFormatter, list;
        headding = document.createElement('h1');
        kFormatter = function(num) {
          if (num > 999) {
            return (num / 1000).toFixed(1) + 'K';
          } else {
            return num;
          }
        };
        infoFormatter = function(infos) {
          var key, list;
          list = '';
          for (key in infos) {
            key = key;
            if (!isNaN(infos[key])) {
              list += '<li><h2>' + kFormatter(infos[key]) + '</h2><p>' + key.replaceAll('_', ' ') + '</p></li>';
            }
          }
          return list;
        };
        headding.id = 'product-name';
        headding.innerHTML = name;
        img = document.createElement('img');
        img.src = image;
        a = document.createElement('a');
        a.href = link;
        a.target = '_blank';
        a.append(img);
        list = document.createElement('ul');
        list.innerHTML = infoFormatter(data);
        cImg = document.createElement('div');
        cImg.id = 'product-image';
        cImg.className = 'left';
        cImg.append(headding);
        cImg.append(a);
        cInfo = document.createElement('div');
        cInfo.id = 'product-stats';
        cInfo.className = 'left';
        cInfo.append(list);
        cProduct = document.createElement('div');
        cProduct.id = 'product';
        cProduct.className = 'left';
        cProduct.append(cImg);
        cProduct.append(cInfo);
        c = document.createElement('div');
        c.id = 'container';
        c.className = 'left';
        c.append(cProduct);
        return c;
      },
      gauge: function(data, element) {
        var Needle, arc, arcEndRad, arcStartRad, barWidth, chart, chartInset, degToRad, el, endPadRad, height, i, margin, needle, numSections, padRad, percToDeg, percToRad, percent, radius, ref, sectionIndx, sectionPerc, startPadRad, svg, totalPercent, width;
        Needle = void 0;
        arc = void 0;
        arcEndRad = void 0;
        arcStartRad = void 0;
        barWidth = void 0;
        chart = void 0;
        chartInset = void 0;
        degToRad = void 0;
        el = void 0;
        endPadRad = void 0;
        height = void 0;
        i = void 0;
        margin = void 0;
        needle = void 0;
        numSections = void 0;
        padRad = void 0;
        percToDeg = void 0;
        percToRad = void 0;
        percent = void 0;
        radius = void 0;
        ref = void 0;
        sectionIndx = void 0;
        sectionPerc = void 0;
        startPadRad = void 0;
        svg = void 0;
        totalPercent = void 0;
        width = void 0;
        percent = data;
        barWidth = 20;
        numSections = 5;
        sectionPerc = 1 / numSections / 2;
        padRad = 0;
        chartInset = 10;
        totalPercent = .75;
        el = d3.select(element);
        margin = {
          top: 20,
          right: 20,
          bottom: 30,
          left: 20
        };
        width = el[0][0].offsetWidth - margin.left - margin.right;
        height = width;
        radius = Math.min(width, height) / 2;
        percToDeg = function(perc) {
          return perc * 360;
        };
        percToRad = function(perc) {
          return degToRad(percToDeg(perc));
        };
        degToRad = function(deg) {
          return deg * Math.PI / 180;
        };
        svg = el.append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom);
        chart = svg.append('g').attr('transform', 'translate(' + (width + margin.left) / 2 + ', ' + (height + margin.top) / 2 + ')');
        Needle = (function() {
          var Needle;
          Needle = function(len, cl) {
            this.len = len;
            this.cl = cl;
          };
          Needle.prototype.drawOn = function(el, perc) {
            return el.append('path').attr('class', this.cl).attr('d', this.mkCmd(perc));
          };
          Needle.prototype.animateOn = function(el, perc) {
            var self;
            self = void 0;
            self = this;
            return el.transition().delay(500).ease('elastic').duration(3000).selectAll('.' + this.cl).tween('progress', function() {
              return function(percentOfPercent) {
                var progress;
                progress = void 0;
                progress = percentOfPercent * perc;
                return d3.select(this).attr('d', self.mkCmd(progress));
              };
            });
          };
          Needle.prototype.mkCmd = function(perc) {
            var centerX, centerY, endX, endY, startX, startY, thetaRad;
            thetaRad = void 0;
            thetaRad = percToRad(perc / 2);
            centerX = 0;
            centerY = 0;
            startX = centerX - ((this.len + 30) * Math.cos(thetaRad));
            startY = centerY - ((this.len + 30) * Math.sin(thetaRad));
            endX = centerX - ((this.len - 10) * Math.cos(thetaRad));
            endY = centerY - ((this.len - 10) * Math.sin(thetaRad));
            return 'M ' + startX + ' ' + startY + ' L ' + endX + ' ' + endY;
          };
          return Needle;
        })();
        needle = new Needle(100, "needle");
        needle.drawOn(chart, 0);
        needle.animateOn(chart, percent);
        sectionIndx = i = 1;
        ref = numSections;
        while ((1 <= ref ? i <= ref : i >= ref)) {
          arcStartRad = percToRad(totalPercent);
          arcEndRad = arcStartRad + percToRad(sectionPerc);
          totalPercent += sectionPerc;
          startPadRad = sectionIndx === 0 ? 0 : padRad / 2;
          endPadRad = sectionIndx === numSections ? 0 : padRad / 2;
          arc = d3.svg.arc().outerRadius(radius - chartInset).innerRadius(radius - chartInset - barWidth).startAngle(arcStartRad + startPadRad).endAngle(arcEndRad - endPadRad);
          chart.append('path').attr('class', 'arc chart-color' + sectionIndx).attr('d', arc);
          sectionIndx = 1 <= ref ? ++i : --i;
        }
      },
      sankey: function(data, dimensions, metric, element) {
        var color, dragmove, el, format, formatData, formatNumber, graph, height, link, margin, node, nodeMap, path, svg, units, width;
        units = metric;
        formatData = function(raw, dimensions, metric) {
          var d, dimension, drills, flags, formatted, i, j, k;
          formatted = {};
          formatted.links = [];
          formatted.nodes = [];
          drills = {};
          flags = [];
          i = 0;
          while (i < raw[dimensions[0]].length) {
            for (j in dimensions) {
              j = parseInt(j);
              dimension = dimensions[j];
              if (flags.indexOf(raw[dimension][i].raw_data.toString()) === -1) {
                flags.push(raw[dimension][i].raw_data.toString());
                formatted.nodes.push({
                  name: raw[dimension][i].raw_data.toString()
                });
              }
              if (j < dimensions.length - 1) {
                d = raw[dimensions[j]][i].raw_data + ':' + raw[dimensions[j + 1]][i].raw_data;
                if (flags.indexOf(d) === -1) {
                  flags.push(d);
                  drills[d] = {
                    source: raw[dimensions[j]][i].raw_data,
                    target: raw[dimensions[j + 1]][i].raw_data,
                    value: raw[metric][i].raw_data
                  };
                } else {
                  drills[d].value += raw[metric][i].raw_data;
                }
              }
            }
            i++;
          }
          for (k in drills) {
            k = k;
            formatted.links.push(drills[k]);
          }
          return formatted;
        };
        dragmove = function(d) {
          d3.select(this).attr('transform', 'translate(' + (d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))) + ',' + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ')');
          sankey.relayout();
          link.attr('d', path);
        };
        el = d3.select(element);
        margin = {
          top: 10,
          right: 10,
          bottom: 10,
          left: 10
        };
        width = el[0][0].offsetWidth - margin.left - margin.right;
        height = el[0][0].offsetHeight - margin.top - margin.bottom;
        formatNumber = d3.format(',.0f');
        format = function(d) {
          return formatNumber(d) + ' ' + units;
        };
        color = d3.scale.ordinal().range(["#9CDBFB", "#47CCFA", "#329DE5", "#C3C3DA", "#8488B2", "#072269", "#3C53B9", "#333333", "#AAAAAA", "#E5E5E5"]);
        svg = d3.select(element).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        sankey = d3.sankey().nodeWidth(8).nodePadding(5).size([width, height]);
        path = sankey.link();
        graph = formatData(data, dimensions, metric);
        nodeMap = {};
        graph.nodes.forEach(function(x) {
          nodeMap[x.name] = x;
        });
        graph.links = graph.links.map(function(x) {
          return {
            source: nodeMap[x.source],
            target: nodeMap[x.target],
            value: x.value
          };
        });
        sankey.nodes(graph.nodes).links(graph.links).layout(32);
        link = svg.append('g').selectAll('.link').data(graph.links).enter().append('path').attr('class', 'link').attr('d', path).style('stroke-width', function(d) {
          return Math.max(1, d.dy);
        }).sort(function(a, b) {
          return b.dy - a.dy;
        });
        link.append('title').text(function(d) {
          return d.source.name + ' → ' + d.target.name + '\n' + format(d.value);
        });
        node = svg.append('g').selectAll('.node').data(graph.nodes).enter().append('g').attr('class', 'node').attr('transform', function(d) {
          return 'translate(' + d.x + ',' + d.y + ')';
        }).call(d3.behavior.drag().origin(function(d) {
          return d;
        }).on('dragstart', function() {
          this.parentNode.appendChild(this);
        }).on('drag', dragmove));
        node.append('rect').attr('height', function(d) {
          return d.dy;
        }).attr('width', sankey.nodeWidth()).style('fill', function(d) {
          return d.color = color(d.name.replace(RegExp(' .*'), ''));
        }).append('title').text(function(d) {
          return d.name + '\n' + format(d.value);
        });
        return node.append('text').attr('x', -6).attr('y', function(d) {
          return d.dy / 2;
        }).attr('dy', '.35em').attr('text-anchor', 'end').attr('transform', null).text(function(d) {
          return d.name;
        }).filter(function(d) {
          return d.x < width / 2;
        }).attr('x', 6 + sankey.nodeWidth()).attr('text-anchor', 'start');
      }
    };
  });

}).call(this);
