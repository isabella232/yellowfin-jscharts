// Generated by CoffeeScript 1.10.0
(function() {
  define(["js/chartingLibraries/d3_3.5.17/d3_3.5.17.min"], function(d3) {
    return d3.sankey = function() {
      var center, computeLinkDepths, computeNodeBreadths, computeNodeDepths, computeNodeLinks, computeNodeValues, links, moveSinksRight, moveSourcesRight, nodePadding, nodeWidth, nodes, sankey, scaleNodeBreadths, size, value;
      sankey = {};
      nodeWidth = 24;
      nodePadding = 8;
      size = [1, 1];
      nodes = [];
      links = [];
      computeNodeLinks = function() {
        nodes.forEach(function(node) {
          node.sourceLinks = [];
          node.targetLinks = [];
        });
        links.forEach(function(link) {
          var source, target;
          source = link.source;
          target = link.target;
          if (typeof source === 'number') {
            source = link.source = nodes[link.source];
          }
          if (typeof target === 'number') {
            target = link.target = nodes[link.target];
          }
          source.sourceLinks.push(link);
          target.targetLinks.push(link);
        });
      };
      computeNodeValues = function() {
        nodes.forEach(function(node) {
          node.value = Math.max(d3.sum(node.sourceLinks, value), d3.sum(node.targetLinks, value));
        });
      };
      computeNodeBreadths = function() {
        var nextNodes, remainingNodes, x;
        remainingNodes = nodes;
        nextNodes = void 0;
        x = 0;
        while (remainingNodes.length) {
          nextNodes = [];
          remainingNodes.forEach(function(node) {
            node.x = x;
            node.dx = nodeWidth;
            node.sourceLinks.forEach(function(link) {
              nextNodes.push(link.target);
            });
          });
          remainingNodes = nextNodes;
          ++x;
        }
        moveSinksRight(x);
        scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
      };
      moveSourcesRight = function() {
        nodes.forEach(function(node) {
          if (!node.targetLinks.length) {
            node.x = d3.min(node.sourceLinks, function(d) {
              return d.target.x;
            }) - 1;
          }
        });
      };
      moveSinksRight = function(x) {
        nodes.forEach(function(node) {
          if (!node.sourceLinks.length) {
            node.x = x - 1;
          }
        });
      };
      scaleNodeBreadths = function(kx) {
        nodes.forEach(function(node) {
          node.x *= kx;
        });
      };
      computeNodeDepths = function(iterations) {
        var alpha, ascendingDepth, initializeNodeDepth, nodesByBreadth, relaxLeftToRight, relaxRightToLeft, resolveCollisions;
        nodesByBreadth = d3.nest().key(function(d) {
          return d.x;
        }).sortKeys(d3.ascending).entries(nodes).map(function(d) {
          return d.values;
        });
        initializeNodeDepth = function() {
          var ky;
          ky = d3.min(nodesByBreadth, function(nodes) {
            return (size[1] - ((nodes.length - 1) * nodePadding)) / d3.sum(nodes, value);
          });
          nodesByBreadth.forEach(function(nodes) {
            nodes.forEach(function(node, i) {
              node.y = i;
              node.dy = node.value * ky;
            });
          });
          links.forEach(function(link) {
            link.dy = link.value * ky;
          });
        };
        relaxLeftToRight = function(alpha) {
          var weightedSource;
          weightedSource = function(link) {
            return center(link.source) * link.value;
          };
          nodesByBreadth.forEach(function(nodes, breadth) {
            nodes.forEach(function(node) {
              var y;
              if (node.targetLinks.length) {
                y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
                node.y += (y - center(node)) * alpha;
              }
            });
          });
        };
        relaxRightToLeft = function(alpha) {
          var weightedTarget;
          weightedTarget = function(link) {
            return center(link.target) * link.value;
          };
          nodesByBreadth.slice().reverse().forEach(function(nodes) {
            nodes.forEach(function(node) {
              var y;
              if (node.sourceLinks.length) {
                y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
                node.y += (y - center(node)) * alpha;
              }
            });
          });
        };
        resolveCollisions = function() {
          nodesByBreadth.forEach(function(nodes) {
            var dy, i, n, node, y0;
            node = void 0;
            dy = void 0;
            y0 = 0;
            n = nodes.length;
            i = void 0;
            nodes.sort(ascendingDepth);
            i = 0;
            while (i < n) {
              node = nodes[i];
              dy = y0 - node.y;
              if (dy > 0) {
                node.y += dy;
              }
              y0 = node.y + node.dy + nodePadding;
              ++i;
            }
            dy = y0 - nodePadding - size[1];
            if (dy > 0) {
              y0 = node.y -= dy;
              i = n - 2;
              while (i >= 0) {
                node = nodes[i];
                dy = node.y + node.dy + nodePadding - y0;
                if (dy > 0) {
                  node.y -= dy;
                }
                y0 = node.y;
                --i;
              }
            }
          });
        };
        ascendingDepth = function(a, b) {
          return a.y - b.y;
        };
        initializeNodeDepth();
        resolveCollisions();
        alpha = 1;
        while (iterations > 0) {
          relaxRightToLeft(alpha *= .99);
          resolveCollisions();
          relaxLeftToRight(alpha);
          resolveCollisions();
          --iterations;
        }
      };
      computeLinkDepths = function() {
        var ascendingSourceDepth, ascendingTargetDepth;
        ascendingSourceDepth = function(a, b) {
          return a.source.y - b.source.y;
        };
        ascendingTargetDepth = function(a, b) {
          return a.target.y - b.target.y;
        };
        nodes.forEach(function(node) {
          node.sourceLinks.sort(ascendingTargetDepth);
          node.targetLinks.sort(ascendingSourceDepth);
        });
        nodes.forEach(function(node) {
          var sy, ty;
          sy = 0;
          ty = 0;
          node.sourceLinks.forEach(function(link) {
            link.sy = sy;
            sy += link.dy;
          });
          node.targetLinks.forEach(function(link) {
            link.ty = ty;
            ty += link.dy;
          });
        });
      };
      center = function(node) {
        return node.y + node.dy / 2;
      };
      value = function(link) {
        return link.value;
      };
      sankey.nodeWidth = function(_) {
        if (!arguments.length) {
          return nodeWidth;
        }
        nodeWidth = +_;
        return sankey;
      };
      sankey.nodePadding = function(_) {
        if (!arguments.length) {
          return nodePadding;
        }
        nodePadding = +_;
        return sankey;
      };
      sankey.nodes = function(_) {
        if (!arguments.length) {
          return nodes;
        }
        nodes = _;
        return sankey;
      };
      sankey.links = function(_) {
        if (!arguments.length) {
          return links;
        }
        links = _;
        return sankey;
      };
      sankey.size = function(_) {
        if (!arguments.length) {
          return size;
        }
        size = _;
        return sankey;
      };
      sankey.layout = function(iterations) {
        computeNodeLinks();
        computeNodeValues();
        computeNodeBreadths();
        computeNodeDepths(iterations);
        computeLinkDepths();
        return sankey;
      };
      sankey.relayout = function() {
        computeLinkDepths();
        return sankey;
      };
      sankey.link = function() {
        var curvature, link;
        curvature = .5;
        link = function(d) {
          var x0, x1, x2, x3, xi, y0, y1;
          x0 = d.source.x + d.source.dx;
          x1 = d.target.x;
          xi = d3.interpolateNumber(x0, x1);
          x2 = xi(curvature);
          x3 = xi(1 - curvature);
          y0 = d.source.y + d.sy + d.dy / 2;
          y1 = d.target.y + d.ty + d.dy / 2;
          return 'M' + x0 + ',' + y0 + 'C' + x2 + ',' + y0 + ' ' + x3 + ',' + y1 + ' ' + x1 + ',' + y1;
        };
        link.curvature = function(_) {
          if (!arguments.length) {
            return curvature;
          }
          curvature = +_;
          return link;
        };
        return link;
      };
      return sankey;
    };
  });

}).call(this);
